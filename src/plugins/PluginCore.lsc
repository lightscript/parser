// Stable sort
stableSort(arr, comparator) ->
  len = arr.length
  entries = Array(len)
  for (let index = 0; index < len; index++) entries[index] = [index, arr[index]]
  newComparator = ((a, b) -> Number(this(a[1], b[1])) or (a[0] - b[0])).bind(comparator)
  entries.sort(newComparator)
  for (let index = 0; index < len; index++) arr[index] = entries[index][1]
  arr

// New getParser implementation
import Parser from '../parser'

export function getParser(options, input) {
  if (!options) now options = {};
  if (!options.plugins) options.plugins = [];

  // Create plugin manager
  let pluginManager = new PluginManager();
  if (options.pluginManager) {
    now pluginManager = options.pluginManager;
  }
  pluginManager.addPlugins(options.plugins);

  // Validate and load plugins
  pluginManager.resolveActualPlugins();
  pluginManager.validate();
  pluginManager.load();

  // Replace options.plugins with actual list
  options.plugins = pluginManager.actualPluginBabelOpts()

  const cls = pluginManager.getParserClass(Parser);
  return new cls(options, input);
}

// Plugin registry
pluginsByName = {}

export registerPlugin(p): void ->
  n = p.getName()
  if pluginsByName[n]:
    throw new Error(`Duplicate plugin named '${n}' has been registered.`)
  pluginsByName[n] = p

export pluginForName(n) ->
  p = pluginsByName[n]
  if not p:
    throw new Error(`Could not find plugin named '${n}'`)
  p

export maybePluginForName(n) -> pluginsByName[n]

// Plugin manager
parserClassCache = {}

export class PluginManager:
  constructor() ->
    this.requestedPlugins = []
    this.namedPluginOptions = {}
    this.actualPlugins = []

  addPlugin(name, opts): void ->
    this.requestedPlugins.push(pluginForName(name))
    // Merge options in the event of dupe
    curOpts = this.namedPluginOptions[name]
    if curOpts:
      Object.assign(curOpts, opts)
    else:
      this.namedPluginOptions[name] = opts or {}

  addPlugins(babelPluginsList): void ->
    for elem e in (babelPluginsList or []):
      if Array.isArray(e): this.addPlugin(e[0], e[1]) else: this.addPlugin(e)

  // Ban all named plugins, including banning plugins that depend upon them.
  banPlugins(list): void ->
    bannedPlugins = [...for elem name in list: pluginForName(name).dependents()]
    this.requestedPlugins = this.requestedPlugins.filter(x -> bannedPlugins.indexOf(x) == -1)

  resolveActualPlugins() ->
    loadOrderEntriesByName = {}
    // Duped load order: fully unwound dependencies for each plugin, concatenated in idealized load order
    dupedLoadOrder = [...for elem p in this.requestedPlugins: p.unwoundDependencies() ]
    //console.log("dupedLoadOrder", dupedLoadOrder)
    // Deduped load order: only one entry for each plugin, when it first appears
    dedupedLoadOrder = [...for elem p in dupedLoadOrder:
      pluginName = p.getName()
      if not loadOrderEntriesByName[pluginName]:
        loadOrderEntriesByName[pluginName] = p
        [p]
    ]
    //console.log("dedupedLoadOrder", dedupedLoadOrder)
    // Now sort by plugin load order priority
    stableSort(dedupedLoadOrder, (a, b) -> a.getLoadOrderPriority() - b.getLoadOrderPriority())

    this.actualPlugins = dedupedLoadOrder
    //console.log("requestedPlugins", this.requestedPlugins, "actualPlugins", this.actualPlugins)

  actualPluginNames() -> [...for elem p in this.actualPlugins: [p.getName()]]

  actualPluginBabelOpts() -> [...for elem p in this.actualPlugins:
    pluginName = p.getName()
    if this.namedPluginOptions[pluginName]:
      [ [pluginName, this.namedPluginOptions[pluginName]] ]
    else:
      [pluginName]
  ]

  hasActualPlugin(p): boolean ->
    if typeof(p) == 'string':
      this.actualPluginNames().indexOf(p) > -1
    else:
      this.actualPlugins.indexOf(p) > -1

  validate(): void ->
    for elem p in this.actualPlugins: p.validate(this, this.namedPluginOptions[p.getName()])

  load(): void ->
    for elem p in this.actualPlugins: p.load(this.namedPluginOptions[p.getName()])

  getParserClass(Parser) ->
    mixinPlugins = this.actualPlugins.filter(p -> p.hasMixin())

    key = mixinPlugins.map(p -> p.getName()).join('/')
    let cls = parserClassCache[key]
    if not cls:
      now cls = Parser
      for elem plugin in mixinPlugins:
        now cls = plugin.mixin(cls, this.namedPluginOptions[plugin.getName()])
      parserClassCache[key] = cls

    //console.log("mixinPlugins", mixinPlugins, "mixedClass", cls)
    cls

export class Plugin:
  constructor(opts) ->
    this.name = opts.name
    this.dependencies = opts.dependencies or []
    this.incompatibilities = opts.incompatibilities or []
    this.loadOrderPriority = opts.loadOrderPriority or 0
    this._validate = opts.validate or (-> true)
    this._load = opts.load or (-> return)
    this._mixin = opts.mixin

  getName() -> this.name

  getLoadOrderPriority() -> this.loadOrderPriority

  resolvedDependencies() ->
    [...for elem name in this.dependencies: [pluginForName(name)]]

  unwoundDependencies() ->
    result = [...for elem dep in this.resolvedDependencies(): dep.unwoundDependencies()]
    result.push(this)
    result

  dependents() ->
    [...for key name, val plugin in pluginsByName:
      if plugin.unwoundDependencies().indexOf(this) > -1:
        [plugin]
    ]

  dependsOn(p): boolean ->
    if typeof(p) == 'string':
      this.dependsOn(maybePluginForName(p))
    elif p:
      this.unwoundDependencies().indexOf(p) > -1
    else:
      false

  hasMixin(): boolean ->
    if this._mixin: true else: false

  mixin(ParserBase, opts) ->
    this._mixin(ParserBase, opts)

  validate(mgr, opts): void ->
    for elem name in this.incompatibilities:
      if mgr.hasActualPlugin(name):
        throw new Error(`Plugin '${this.getName()}' is incompatible with plugin '${name}'`)
    this._validate(opts, mgr)

  load(opts): void ->
    this._load(opts)

// Register all available plugins.
import { registerPlugins } from './PluginRegistration'
registerPlugins(registerPlugin, Plugin)
