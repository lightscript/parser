import { Plugin } from '../core/plugin'
import { types as tt, TokenType, registerToken } from "../../tokenizer/register"
import * as charCodes from "charcodes"

tildeCall = new Plugin({
  name: 'tildeCall'

  mixin(ParserBase, opts) -> {
    return class extends ParserBase {
      constructor(options, input) -> {
        super(options, input)
        this.tt_tildeCall = new TokenType("~>")
      }

      tildeCall_parseCallee() -> {
        // Allow `this` or ordinary identifiers only
        callee = if this.match(tt._this):
          this.parseExprAtom()
        else:
          this.parseIdentifier() // parseIdentifierOrPlaceholder() for match
        // Don't allow further calls as subscripts in the callee
        this.parseSubscripts(callee, this.state.start, this.state.startLoc, true)
      }

      // Parse `a~b(...)` or `a~>b(...)`
      tildeCall_parse(node, firstArg) -> {
        this.next()
        node.callee = this.tildeCall_parseCallee()

        // Allow safe-callee tilde calls `a~b?(c)`
        if (
          this.hasPlugin("optionalChaining") &&
          this.isAdjacent() &&
          this.eat(tt.question)
        ) {
          node.optional = true;
        }

        // Allow bang tilde calls
        if (this.hasPlugin("bangCall") && this.isAdjacentBang()) {
          const next = this.parseBangCall(node, "CallExpression");
          node.arguments.unshift(firstArg);
          node.tilde = true;
          if (next) {
            return next;
          } else {
            return false;
          }
        } else {
          if (node.optional && this.state.lastTokEnd !== (this.state.pos - 1)) {
            this.unexpected(null, "Whitespace is forbidden after `?` in an optional call.");
          }
          this.expect(tt.parenL);
          node.arguments = this.parseCallExpressionArguments(tt.parenR, false);
          node.arguments.unshift(firstArg);
          node.tilde = true;
          return this.finishNode(node, "CallExpression");
        }
      } // tildeCall_parse

      /////////////////////
      // OVERRIDES
      /////////////////////

      // Modify tokenizer to intercept `~`
      getTokenFromCode(code) -> {
        if code == charCodes.tilde:
          if this.input.charCodeAt(this.state.pos + 1) == charCodes.greaterThan:
            this.state.pos += 2
            return this.finishToken(this.tt_tildeCall, "~>")

          if this.hasPlugin("disableBitwiseOperators"):
            ++this.state.pos
            return this.finishToken(this.tt_tildeCall, "~")

        super.getTokenFromCode(code)
      }

      // Hook subscript parsing chain to catch `~` token
      parseSubscript(base, startPos, startLoc, noCalls, state) -> {
        if (not noCalls) and this.match(this.tt_tildeCall):
          node = this.startNodeAt(startPos, startLoc)
          next = this.tildeCall_parse(node, base)
          if next:
            return next
          else:
            state.stop = true
            return node

        super.parseSubscript(base, startPos, startLoc, noCalls, state)
      }
    } // class
  } // mixin
})

export default tildeCall
