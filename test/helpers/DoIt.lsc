import { TestRun, Testable, TestOptions } from './TestRunner'
import { allTests, TestFilter } from './TestFilter'
import path from 'path'
import { parse } from '../../lib'
import misMatch from './misMatch'

class ParserTestOptions extends TestOptions:
  inherits(other): void ->
    if not other: return
    for key k, val v in other:
      match k:
        | 'throws': null
        | else: this[k] = v

  assign(other): void ->
    if not other: return
    for key k, val v in other:
      match k:
        | 'includePlugins':
          this[k] = (this[k] or []).concat(v)
        | else:
          this[k] = v

class ParserTestable extends Testable:
  loadTest(): void ->
    this.loadTestData()
    this.enqueueTest()

  readTestOptions() ->
    optionsData = this.readLocalArtifact("options.json", false)
    options = if optionsData: JSON.parse(optionsData) else: {}
    // Allow test options to be overridden
    overrideData = this.readLocalArtifact("options.override.json", false)
    if overrideData:
      Object.assign(options, JSON.parse(overrideData))
    options

  loadTestData(): void ->
    if this.name and this.name[0] == '.':
      this.disabled = true
      return

    options = this.readTestOptions()
    if options: this.options.assign(options)
    //console.log("Test options:", this.title, this.options)

    this.actual = this.readLocalArtifact("input", true)
    this.expected = this.readLocalArtifact("output.json", false)

    // Use parent input if no child input.
    if (not this.actual) and (this.parent) and (this.parent.actual):
      if not this.expected: this.expected = this.parent.expected
      this.actual = this.parent.actual

  enqueueTest(): void ->
    if this.actual:
      // Get `it` from Jest global
      testFn = if typeof(it) != 'undefined': if this.disabled: it?.skip else: it
      if testFn:
        testFn(this.title, => this.runTest())
      else:
        console.log("enqueuing", this.title)
    else:
      // console.log("skipping (no input)", this.title)
      return

  throwAnnotatedError(err): void ->
    err.message = this.title + ": " + err.message
    throw err

  runTest(): void ->
    let ast
    try {
      now ast = this.run.parse(this.actual, this.options)
    } catch(err) {
      if this.options.throws:
        if err.message == this.options.throws:
          return
        elif process.env.SAVE_THROWS:
          this.saveThrows(err)
          this.throwAnnotatedError(err)
        else:
          err.message = `Expected error message: ${this.options.throws}. Got error message: ${err.message}`
          this.throwAnnotatedError(err)
      elif (not this.expected) and (process.env.SAVE_THROWS):
        this.saveThrows(err)

      this.throwAnnotatedError(err)
    }

    if this.options.throws:
      this.throwAnnotatedError(new Error(`Expected error message '${this.options.throws}' but no error was thrown.`))

    // Don't store comments in expected output
    if (ast.comments && !ast.comments.length) delete ast.comments

    if (not this.expected) and (not this.options.throws) and (process.env.SAVE_EXPECTED):
      this.saveExpected(ast)
      return

    if this.options.throws:
      this.throwAnnotatedError(new Error(
        "Expected error message: " + this.options.throws + ". But parsing succeeded."
      ))
    else:
      if this.expected:
        mis = misMatch(JSON.parse(this.expected), ast)
        if mis: this.throwAnnotatedError(new Error("Mismatch against expected output: " + mis))
      else:
        this.throwAnnotatedError(new Error("Empty expected output -- use SAVE_EXPECTED=1 to create expected output."))

  saveExpected(ast): void ->
    toJSON = RegExp.prototype.toJSON
    RegExp.prototype.toJSON = RegExp.prototype.toString
    jsonAst = JSON.stringify(ast, null, "  ")
    RegExp.prototype.toJSON = toJSON

    this.saveLocalArtifact("output.json", jsonAst)

  saveThrows(err): void ->
    const opts = this.readTestOptions() or {}
    opts.throws = err.message
    this.saveLocalArtifact("options.json", JSON.stringify(opts, null, "  "))

run = new TestRun()
run.parse = parse
run.getTestableConstructor() -> ParserTestable
run.getOptionsConstructor() -> ParserTestOptions
run.extensions = ['.js', '.lsc', '.lsx']

filter = new TestFilter()
if process.env.ONLY:
  filter.only(process.env.ONLY)

rootTestable = new ParserTestable(run, null, filter)
rootTestable.setTestPath(path.join(__dirname, '../fixtures'))
rootTestable.readTestDirectory()
